





##Aim:
###Simulate the transmission of ping messages over a network topology consisting of 6 nodes and find the number of packets dropped due to congestion. 

###Description:

> Ping sends ICMP ECHO_REQUEST to network hosts. Ping uses the ICMP  protocol's  mandatory  ECHO_REQUEST  datagram  to elicit  an  ICMP  ECHO_RESPONSE from a host or gateway.  ECHO_REQUEST datagrams ("pings") have an IP  and  ICMP  header, followed  by a struct  timeval and then an arbitrary number of ``pad'' bytes used to fill out the packet.

###Packages required to be pre-installed:

* (if they dont already exist)
* openjdk6-jre-headless or openjdk7-jre-headless
* nam
* ns2

###Instructions to Simulate:
1. Open ns2g2.jar by right clicking on the jar file and choosing open with java. Ns2g2.jar file is java dependent.
2. On the editing panel, choose **Scenario**, and select **Wired Scenario**.
3. The **node** tab is to be selected next to place the nodes on the grid. This program requires the user to have 6 nodes in the network. Draw 6 nodes on the network.
4. The **link** tab provides the user to link the nodes in the grid. Connect all the nodes. Select **Link type** as **duplex**(bi-directional link), **Queue** type as **Droptail**(indication stating the packets are to be dropped at destination only), **capacity** as **1Mbps**, **propagation delay** as **10ms** and **queue size** as desirable(i.e 5, 10, etc.)
5. After finishing the topology, click on **TCL** tab. It generates the code and save it where required as a .tcl file.
6. After saving, open the file in a text editor.(like nano, gedit, vi etc)
7. Now enter the following code under the agent definition header:	
<code>	
	//creating an agent object <br/>
	set ping0 [new Agent/Ping]<br/> 
	//agent object node0<br/>	
	$ns attach-agent $n0 $ping0<br/>
	set ping1 [new Agent/Ping]<br/>
	//agent object node1<br/>
	$ns attach-agent $n1 $ping1
	set ping4 [new Agent/Ping]<br/>
	//agent object node4<br/>
	$ns attach-agent $n4 $ping4
	set ping5 [new Agent/Ping]<br/>
	//agent object node5<br/>
	$ns attach-agent $n5 $ping5
	//node2 and node3 acts as an intermediate nodes<br/>
	//$ns connect $source $destination<br/>
	$ns connect $ping0 $ping4 <br/>
	$ns connect $ping1 $ping5 <br/>
	//function to constantly ping th destination at an interval of 0.01s<br/>
	proc sendPingPacket {} {<br/>
		//global objects<br/>
		global ns ping0 ping1
		//time interval<br/>
		set time 0.01
		//sets now with the current time of simulation<br/>
		set now [$ns now]<br/>
		//when the current simulation time($now) + time($time = 0.01) occurs a ping is sent to the destination<br/>
		$ns at [expr $now + $time] "$ping0 send"<br/>
		$ns at [expr $now + $time] "$ping1 send"<br/>
		//pingPacket is sent<br/>
		$ns at [expr $now + $time] "sendPingPacket"<br/>
	}<br/>
	//In the Tcl code, a procedure 'Agent/Ping recv {from rtt}' has to be defined which allows the user to react to the ping result.<br/>
   	Agent/Ping instproc recv {from rtt} {<br/>
		global seq<br/>
		$self instvar node_<br/>
	}<br/>
	$ns at 0.01 "sendPingPacket"<br/>
	$ns at 10.0 "finish"<br/>

8. Save the file.
9. To run it on terminal, tpye the command, `ns *filename.tcl*`
10. When the code compiles successfully, the Network Animator(nam) will automatically open for the simulation.
11. In nam, click on the play button and simulation will be run.
12. Once the simulation ends, in the terminal, type `cat out.tr | grep ^d | wc -l` to know the number of packets dropped.
13. Multiple scenarios can be generated by changing the values of bandwidth and queue size of the links in the ns2.

###Screenshots:-
![Not Available](3_1.png)

![Not Available](3_2.png)

![Not Available](3_3.png)	





## Aim:
###Write a program for Error Detection using CRC-CCITT(16 bits)

## Description:

> The cyclic redundancy check, or CRC, is a technique for detecting     
errors in digital data, but not for making corrections when errors are detected. It is used primarily in data transmission. 

> In the CRC method, a certain number of check bits, often called a checksum, are appended to the message being transmitted. The receiver can determine whether or not the check bits agree with the data, to ascertain with a certain degree of probability whether or not an error occurred in transmission.

> If an error occurred, the receiver sends a “negative acknowledgement” (NAK) back to the sender, requesting that the message be retransmitted.
The technique is also sometimes applied to data storage devices, such as a disk drive. In this situation each block on the disk would have check bits, and the hardware might automatically initiate a reread of the block when an error is detected, or it might report the error to software. The material that follows speaks in terms of a “sender” and a “receiver” of a “message,” but it should be understood that it applies to storage writing and reading as well.

> 	

## Algorithm
1. Start
2. Enter the message to be transmitted
3. Append the message with 16(since it is 16-bit CRC) 0`s (i.e. if you input 5 digit message, the appeneded message should be 21-bits.)
4. XOR appended message and transmit it.(Here, you compare with an already exisitng string such as `10001000000100001` and replace the bits the same way XOR operation works)
5. Verify the message that is received is the same as the one sent.
6. End 

## Code:
<code>

    #include<iostream>/*includes input, output streams for C++ programs*/
    #include<stdio.h>
    #include<string.h>/*helps in accessing string modifying functions*/
    using namespace std;
    int crc(char *input,char *output,const char *gp,int mode)
    {
	int j,k;
	strcpy(output,input);/*copy contents of input to output*/
	if(mode)/*if mode == 1, then continue. 1 is interpreted as boolean value `TRUE`*/
	{
		for(j=1; j<strlen(gp); j++) 
			strcat(output,"0");/*append output with 0`s depending on the length of gp. here it is 17*/
	}
	for(j=0; j<strlen(input); j++)/*This is XOR operation using iteration and comparison*/
		if(*(output+j) == '1')
			for(k=0; k<strlen(gp); k++)
			{
				if (((*(output+j+k) =='0') && (gp[k] == '0') ||	(*(output+j+k) == '1') && (gp[k] == '1'))) 
					*(output+j+k)='0';
				else
					*(output+j+k)='1';
			}
	for(j=0; j<strlen(output); j++)
		if(output[j] == '1')
			return 1;
	return 0;
}

	int main()
	{
		char input[50],output[50],recv[50];
		const char gp[18]="10001000000100001";
		cout<<"\nEnter the input message in binary\n";
		cin>>input;
		crc(input,output,gp,1);
		cout<<"\nThe transmitted message is: "<<input<<output+strlen(input)<<"\n";
		cout<<"\n\nEnter the recevied message in binary \n";
		cin>>recv;
		if(!crc(recv,output,gp,0))
			cout<<"\nNo error in data\n";
		else
			cout<<"\nError in data transmission has occurred\n";
	
		return 0;
	}
</code>

###Output:
*Commands for execution:-*

* Open a terminal.
* Change directory to the file location.
* Run g++ *filename.cpp* 
* If there are no errors, run ./a.out

*Screenshots:-*

![ScreenShot of output](crc.png)






## Aim: 
### Write a program for distance vector algorithm to find suitable path for transmission.

## Theory
> Routing algorithm is a part of network layer software which is responsible for deciding which
output line an incoming packet should be transmitted on. If the subnet uses datagram internally, this
decision must be made anew for every arriving data packet since the best route may have changed
since last time. If the subnet uses virtual circuits internally, routing decisions are made only when a
new established route is being set up. The latter case is sometimes called session routing, because a
rout remains in force for an entire user session (e.g., login session at a terminal or a file).

> Routing algorithms can be grouped into two major classes: adaptive and non-adaptive.
Nonadaptive algorithms do not base their routing decisions on measurement or estimates of current
traffic and topology. Instead, the choice of route to use to get from I to J (for all I and J) is compute in
advance, offline, and downloaded to the routers when the network ids booted. This procedure is
sometime called static routing.

> Adaptive algorithms, in contrast, change their routing decisions to reflect changes in the
topology, and usually the traffic as well. Adaptive algorithms differ in where they get information
(e.g., locally, from adjacent routers, or from all routers), when they change the routes, and what metric is used for
optimization (e.g., distance, number of hops, or estimated transit time).

> Two algorithms in particular, distance vector routing and link state routing are the most popular.
Distance vector routing algorithms operate by having each router maintain a table (i.e., vector)
giving the best known distance to each destination and which line to get there. These tables are
updated by exchanging information with the neighbour's.
> The distance vector routing algorithm is sometimes called by other names, including the
distributed Bellman-Ford routing algorithm and the Ford-Fulkerson algorithm, after the researchers
who developed it (Bellman, 1957; and Ford and Fulkerson, 1962). It was the original ARPANET
routing algorithm and was also used in the Internet under the RIP and in early versions of DEC net
and Novell'Ps IPX. AppleTalk and Cisco routers use improved distance vector protocols.

> In distance vector routing, each router maintains a routing table indexed by, and containing one
entry for, each router in subnet. This entry contains two parts: the preferred outgoing line to use for
that destination, and an estimate of the time or distance to that destination. The metric used might
be number of hops, time delay in milliseconds, total number of packets queued along the path, or
something similar.

> The router is assumed to know the “distance” to each of its neighbour. If the metric is hops, the
distance is just one hop. If the metric is queue length, the router simply examines each queue. If the
metric is delay, the router can measure it directly with special ECHO packets that the receiver just
time stamps and sends back as fast as possible.

## Algorithm:
1. Start
2. By convention, the distance of the node to itself is assigned to zero and when a node is unreachable the distance is accepted as 999.
3. Accept the input distance matrix from the user (*dm[][]*) that represents the distance between each node in the network.
4. Store the distance between nodes in a suitable varible.
5. Calculate the minimum distance between two nodes by iterating.
	* If the distance between two nodes is larger than the calculated alternate available path, replace the existing distance with the calculated distaance. 
6. Print the shortest path calculated.
7. Stop.

## Code: filename.cpp
    #include<iostream> 
    #include<stdio.h>
    using namespace std;
    struct node // C1: define structure
    {
    	int dist[20];
    	int from[20];
     }rt[10]; // C2: structure variable
    int main()
    {
    	int dm[20][20]; 
    	int i,j,k,n,src,dest,count=0;
    	cout<<"enter no of nodes:"<<endl;
    	cin>>n;
    	cout<<"Enter distance matrix:"<<endl;
    	for(i=0;i<n;i++) // C3: input matrix
    		for(j=0;j<n;j++)
    		{
    			cin>>dm[i][j];
    			dm[i][i]=0;
    			rt[i].dist[j]=dm[i][j]; // C4: node allocations
    			rt[i].from[j]=j;
    		}
    	do
    	{
    		count=0;
    		for(i=0;i<n;i++)
    			for(j=0;j<n;j++)
    				for(k=0;k<n;k++)
    					if((rt[i].dist[j])>(dm[i][k]+rt[k].dist[j])) // C5: check & calculate minumum distance between each node
    					{
    						rt[i].dist[j]=rt[i].dist[k]+rt[k].dist[j];
    						rt[i].from[j]=k;
    						count++;
    					}
    	}while(count!=0);
    	for(i=0;i<n;i++) // C6: Display the shortest path calculated between the nodes
    	{
    		cout<<"Router info for router "<<i+1<<endl;
     		printf("Dest\tNext Hop\tDist\n");
     		for(j=0;j<n;j++)
     			printf("%d\t%d\t\t%d\n",j+1,rt[i].from[j]+1,rt[i].dist[j]);
     	}
    return 0;
    }

## Output:
*Commands for execution:-*

* Open a terminal.
* Change directory to the file location.
* Run g++ *filename.cpp* 
* If there are no errors, run ./a.out

*Screenshots:-*

![ScreenShot of Output](dsv.png)






## Aim: 
### Using TCP/IP sockets, write a client-server program to make client sending the file name and the server to send back the contents of the requested file if present.

## Theory
> This  is  an  implementation of the TCP protocol. It provides a reliable, stream-oriented, full-duplex connection between two sockets on top of IP, for both v4 and v6 versions.  TCP  guarantees  that  the  data arrives in order and retransmits lost packets.  It generates and checks a per-packet checksum to catch transmission errors.  TCP does not preserve record boundaries.

> A newly created TCP socket has no remote or local address and is not fully specified.  To create an  outgoing  TCP  connection  use  connect to  establish  a  connection  to  another  TCP socket.  To receive new incoming connections, first bind the socket to a local address and port and then call listen to put the socket into the listening state.  After that a new socket for each  incoming  connection  can  be  accepted using accept.  A socket which has had accept or connect successfully called on it is fully specified and may transmit data.  Data cannot be transmitted on listening or not yet connected sockets.

## Algorithm: Client Side
1. Start.
2. Create a socket using socket() system call.
3. Connect the socket to the address of the server using connect() system call.
4. Send the filename of required file using send() system call.
5. Read the contents of the file sent by server by recv() system call.
6. Stop.

## Algorithm: Server Side
1. Start.
2. Create a socket using socket() system call.
3. Bind the socket to an address using bind() system call.
4. Listen to the connection using listen() system call.
5. accept connection using accept()
6. Receive filename and transfer contents of file with client.
7. Stop.

## Code: client.c
    #include<stdio.h>
    #include<fcntl.h> 

    // included for file handling using write()
    #include<unistd.h>

    // included to access inet_addr,socket(), send(), recv() method
    #include<arpa/inet.h> 
    
    int main()
    { 
      char fname[50],buffer[1024];
      int s,n;
      struct sockaddr_in address; 

      // sockaddr_in is used for ip manipulation
      address.sin_family=AF_INET; 

      // default family address
      address.sin_port=htons(15000); 

      // port through which IPC is established
      address.sin_addr.s_addr=INADDR_ANY; 

      // any address can be asssigned to the client
      if((s=socket(AF_INET,SOCK_STREAM,0))<0) 
      {  

      // socket() creates an endpoint for communication and returns a descriptor.
      	perror("socket\n");
      	connect(s,(struct sockaddr*)&address,sizeof(address)); 
      }
      
      // connect - initiate a connection on a socket
      printf("enter file name:\n");
      scanf("%s",fname);
      printf("sending request..\n");
      send(s,fname,sizeof(fname),0); 

      // send() is used to transmit a message to another socket.
      printf("received response\n");
      while((n=recv(s,buffer,sizeof(buffer),0))>0) 
      {
      
      // recv() used to receive messages from a socket, and may be used to 
      // receive data on a socket whether or not it is connection-oriented. 
      // Returns a file descriptor
        write(1,buffer,n); 
      }     
    
      // send a message to another user
      return 0;
    }

## Code: server.c
    #include<stdio.h>
    #include<fcntl.h> 
    //included for file handling using write(), read(), open() methods
    #include<unistd.h>
    
    // included to access inet_addr(), bind(), socket(), send(), recv(), accept() method
    #include<arpa/inet.h> 
    
    int main()
    {
      char fname[50],buffer[1024];
      int s,n,source,file;
      struct sockaddr_in address;
      address.sin_family=AF_INET;
      address.sin_port=htons(15000);
      
      // The htons() function converts the unsigned short integer hostshort from 
      // host byte order to network byte order 
      address.sin_addr.s_addr=INADDR_ANY;
      
      // any address can access the server
      printf("waiting for request...\n");
      s=socket(AF_INET,SOCK_STREAM,0);
      bind(s,(struct sockaddr*)&address,sizeof(address));
      listen(s,3);
      
      // listen - listen for connections on a socket
      source=accept(s,(struct sockaddr*)NULL,NULL);
      
      // accept a connection
      recv(source,fname,sizeof(fname),0); 
      
      // receive a message from the client
      printf("request for file %s\n", fname);
      file=open(fname,O_RDONLY);
      
      // open file in read-only mode
      if(file<0)
    		send(source,"file not found\n",20,0);
      else
    		while((n=read(file,buffer,sizeof(buffer)))>0) 
      
                    // read the input being sent by the client
                	send(source,buffer,n,0);
      printf("request sent\n");
      close(file);
      return 0;
    }


## Output:
*Commands for execution:-*

* Open two terminals one for client and  server each.
* Change directory to the file location in both the terminals.
* Run gcc *server.c* -o serv.out in the server terminal.
* If no errors, run ./serv.out
* Run gcc *client.c* -o client.out in the client terminal.
* If no errors, run ./client.out

*Screenshots:-*

![ScreenShot of Output](9.png)






##Aim
Implement message queues or FIFO's using IPC channels.

###Problem statement:
Write a client - sever program to make the client send the file name and to make the server send back the contents of the requested file implementing it by FIFO's or message queues usong IPC channels.

##Description
The program is implemented using a Server-Client model where the server-side 
is being run on one terminal window and the client-side is run on another terminal
window. Initially, server listens to the requests made by the client.
Once the client sends a request, the request is processed by the server.
Now the server is in the read mode, i.e. it can read the read the request.


The client-side ideally consists of a FIFO structure set-up using the "mkfifo" command.
The requests have to be followed by responses from the server-side. 
Hence, another FIFO structure is used to imlplement the response that gets
generated at the server-side. Thus we have two FIFO systems in place, namely 
*request* in read mode and *response* in write mode. 

The request consists of the name of the file. Once a request is placed by the client, 
on the server side, the respective file is opened and contents read. 
The contents are then passed to the FIFO structure of the client side and thus the 
contents are displayed. 

###Algorithm:

####	Server Side
1. Create two string variables for file name and buffer.
2. Create three integer variables for Request,Response and file operations.
3. Create two FIFO files for response and request using the function mkfifo and pass the respective parameters.
4. Pass the request from the client side as any file to the FIFO.
5. Using file operation variable open the file in read mode
6. Check the file for any characters contained in it.
	If not present print File not found.
	else print the contents of the file by passing the contents of the file to the buffer variable using a while loop.
7. Print "request sent".
8. Unlink the response and request file descriptors.


####	Client Side
1. Create two string variables for filename and buffer.
2. Create two integer variables for Request file descriptor and Response descriptors.
3. Using the request file descriptors open the fifo file which has the request queue and using the response ponter open the fifo file which has he resposne queue in it.
4. Pass the name of the file having contents to the filename variable.
5. Output the contents obtained from the server side.
6. Close the request and response descriptors using closde function.


###Code

#### 		Server side
		#include<stdio.h>
		#include<unistd.h>
		#include<fcntl.h>/*used for file handling*/
		#include<sys/stat.h>/*used for mkfifo function*/
		#include<sys/types.h>/*when compiled in gcc, mkfifo() has dependency on both types.h and stat.h*/
		int main()
		{
			char fname[50],buffer[1025];
			int req,res,n,file;
			mkfifo("req.fifo",0777);/*creates a fifo file of permission 777*/
			mkfifo("res.fifo",0777);
			printf("waiting for request...\n");
			req=open("req.fifo",O_RDONLY);/*opens a read-only file req.fifo and stores the file descriptor value in req*/
			res=open("res.fifo",O_WRONLY);/*opens a read-only file res.fifo and stores the file descriptor value in res*/
			read(req,fname,sizeof(fname));/* reads the content of the file req.fifo by referencing the file descriptor value req and stores it in fname array*/
			printf("received request for %s\n",fname);
			file=open(fname,O_RDONLY);/*opens fname as Read-only*/
			if(file<0)
				write(res,"File not found\n",15);
			else
			{
				while((n=read(file,buffer,sizeof(buffer)))>0)
				{
					write(res,buffer,n);
				}
			}
			close(req);
			close(res);	
			unlink("req.fifo");
			unlink("res.fifo");
			return 0;
		}

#### 		Client side

		#include<stdio.h>
		#include<unistd.h>
		#include<fcntl.h>/*used for file handling*/
		#include<sys/stat.h>/*used to access mkfifo() method*/
		#include<sys/types.h>/*when compiled in gcc, mkfifo() has dependency on both types.h and stat.h*/
		int main()
		{
			char fname[50],buffer[1025];
			int req,res,n;
			req=open("req.fifo",O_WRONLY);/*opens a write&read-only file req.fifo and stores the file descriptor value in req*/
			res=open("res.fifo",O_RDONLY);/*opens a read-only file req.fifo and stores the file descriptor value in res*/
			printf("enter filename to request:\n");
			scanf("%s",fname);
			write(req,fname,sizeof(fname));/*writes into fname*/
			printf("received response\n");
			while((n=read(res,buffer,sizeof(buffer)))>0)
			{
				write(1,buffer,n);/*writes content into the buffer*/
			}
			close(req);/*close the file*/
			close(res);
			return 0;
		}

###Output
*Commands for execution:-*

* Open a terminal.
* Change directory to the file location.
* Run g++ *filename.cpp* 
* If there are no errors, run ./a.out

*Screenshots:-*

![ScreenShot of Output](server.png)
![ScreenShot of Output](client.png)






##Aim:
###Write a program for simple RSA algorithm to encrypt and decrypt the data. 

###Description:

> Cryptography has a long and colorful history. The message to be encrypted, known as the plaintext, are transformed by a function that is parameterized by a key. The output of the encryption process, known as the ciphertext, is then transmitted, often by messenger or radio. The enemy, or intruder, hears and accurately copies down the complete ciphertext. However, unlike the intended recipient, he does not know the decryption key and so cannot decrypt the ciphertext easily. The art
of breaking ciphers is called cryptanalysis the art of devising ciphers (cryptography) and breaking them (cryptanalysis) is collectively known as cryptology.

> There are several ways of classifying cryptographic
algorithms. They are generally categorized based on the number of keys that are employed for encryption and decryption, and further defined
by their application and use. The three types of algorithms are as follows:

> 1. Secret Key Cryptography (SKC): Uses a single key for both encryption and decryption. It is also known as symmetric cryptography.
2. Public Key Cryptography (PKC): Uses one key for encryption and another for decryption. It is also known as asymmetric cryptography.
3. Hash Functions: Uses a mathematical transformation to irreversibly "encrypt" information Public-key cryptography has been said to be the most significant new development in cryptography. Modern PKC was first described publicly by Stanford University professor Martin Hellman and graduate student Whitfield Diffie in 1976. Their paper described a two-key cryptosystem in which two parties could engage in a secure communication over a non-secure communications channel without having to share a secret key.

> Generic PKC employs two keys that are mathematically related although knowledge of one key does not allow someone to easily determine the othe
r key. One key is used to encrypt the plaintext and the other key is used to decrypt the ciphertext. The important point here is that it does not matter which key is applied first, but that both keys are required for the process to work. Because pair of keys is required, this approach is also called asymmetric cryptography.

> In PKC, one of the keys is designated the public key and may be advertised as widely as the owner wants. The other key is designated the private key and is never revealed to another party. It is straight forward to send messages under this scheme. The RSA algorithm is named after Ron Rivest, Adi Shamir and Len Adleman, who invented it in
1977.

> The RSA algorithm can be used for both public key encryption and digital signatures. Its security is based on the difficulty of factoring large integers.

###Algorithm:
1. Generate two large random primes, P and Q, of approximately equal size.
2. Compute N=PxQ
3. Compute Z=(P-1) x (Q-1).
4. Choose an integer E, 1<E<Z, such that GCD (E, Z) = 1
5. Compute the secret exponent D, 1<D<Z, such that ExD ≡ 1(mod Z) 

###Code:
	#include <iostream>
	#include <stdlib.h>
	#include <string.h>
	#include <math.h>
	using nam	espace std;
	long int i,e,d,n,p,q,phi,cipher[50];
	int encrypt(char ch);
	char decrypt(long int ch);
	int gcd(long int a,long int b);
	int prime(int a);
	int main()
	{
        		int i,len;
        		char text[50];
        		cout<<"Enter the text to be encrypted: ";
        		cin>>text;
        		len = strlen(text);
			do
        		{
                		p = rand()%30;// generate prime p
        		}while(!prime(p));
	         do
        		{
                		q = rand()%30;  // generate prime number q
        		}while(!prime(q));
        		n=p*q;              //compute n and Φ
        		phi=(p-1)*(q-1);
	         do
        		{
                		e = rand()%phi; //compute E
        		}while(gcd(e,phi)!=1);
	         do
        		{
                		d = rand()%phi; //compute d
        		}while(((d*e)%phi)!=1);
	        cout<<"\n\nTwo prime numbers (p and q) are: "<<p<<" and "<<q<<endl;
  	        cout<<"n(p*q) = "<<p<<" * "<<q<<" = "<<p*q<<endl;
        	        cout<<"Φ(p-1)(q-1) = ("<<p<<"-1) * ("<<q<<"-1) = "<<(p-1)*(q-1)<<endl;
        	        cout<<"Public key (n, e): ("<<n<<", "<<e<<")\n";
        	        cout<<"Private key (Φ, d): ("<<phi<<", "<<d<<")\n";
	        //Encrypt the plain text
        	        for(i=0; i<len; i++)
                 		cipher[i]=encrypt(text[i]);
         	        		cout<<"\n\nEncrypted message: ";
        	        for(i=0; i<len; i++)
                		cout<<cipher[i];

        		//Decrypt the cipher text
        		for(i=0; i<len; i++)
                		text[i]=decrypt(cipher[i]);
        			text[i]='\0';
        			cout<<"\nDecrypted message: "<<text<<endl;

        		return 0;
}

	int gcd(long int a,long int b)
	{
        		if(a==0) return b;
        		if(b==0) return a;
        		return gcd(b ,a%b);
	}

	int prime(int a)
	{
        		for(i=2; i<a; i++)
                		if((a%i)==0)
			      return 0;
        	return 1;
	}

	int encrypt(char ch)
	{
        		long int temp=ch;
        		for(i=1; i<e; i++)
                	temp=(temp*ch)%n;
        		return temp;
	}
	
	char decrypt(long int ch)
	{
        		long int temp=ch;
        		for(i=1; i<d; i++)
                		ch=(temp*ch)%n;
        	return ch;
	}

###Output:
*Commands for execution:-*

> * Open a terminal.
> * Change directory to the file location.
> * Run g++ *filename.cpp* 
> * If there are no errors, run ./a.out

*Screenshots:-*

![ScreenShot of Output](rsa.png)







## Aim:
### Write a program for congestion control using Leaky bucket algorithm.

###Description

>The congesting control algorithms are basically divided into two groups: open loop and closed
loop. Open loop solutions attempt to solve the problem by good design, in essence, to make sure it
does not occur in the first place. Once the system is up and running, midcourse corrections are not
made. Open loop algorithms are further divided into ones that act at source versus ones that act at
the destination.

>In contrast, closed loop solutions are based on the concept of a feedback loop if there is any
congestion. Closed loop algorithms are also divided into two sub categories: explicit feedback and
implicit feedback. In explicit feedback algorithms, packets are sent back from the point of congestion
to warn the source. In implicit algorithm, the source deduces the existence of congestion by making
local observation, such as the time needed for acknowledgment to come back.

>The presence of congestion means that the load is (temporarily) greater than the resources (in
part of the system) can handle. For subnets that use virtual circuits internally, these methods can be
used at the network layer.

>Another open loop method to help manage congestion is forcing the packet to be transmitted at
a more predictable rate. This approach to congestion management is widely used in ATM networks
and is called traffic shaping.

>The other method is the leaky bucket algorithm. Each host is connected to the network by an interface containing a leaky bucket, that is, a finite internal queue. If a packet arrives at the queue when it is full, the packet is discarded. In other words, if one or more process are already queued, the new packet is unceremoniously discarded. This arrangement can be built into the hardware
interface or simulate d by the host operating system. In fact it is nothing other than a single server queuing system with constant service time.

>The host is allowed to put one packet per clock tick onto the network. This mechanism turns an
uneven flow of packet from the user process inside the host into an even flow of packet onto the
network, smoothing out bursts and greatly reducing the chances of congestion.

### Algorithm:
1. Start
2. Set the bucket size or the buffer size.
3. Set the output rate.
4. Transmit the packets such that there is no overflow. 
5. Repeat the process of transmission until all packets are transmitted. (Reject packets where its size is greater than the bucket size)
6. Stop

### Code:
    #include<stdio.h>
    #define NOF_PACKETS 10
    int rand(int a)
    {
     int rn = (random()%10)%a;
     return  rn == 0 ? 1 : rn;
    }
    int main()
    {
     int packet_sz[NOF_PACKETS],i,clk,b_size,o_rate,p_sz_rm=0,p_sz,p_time,op;
     for(i=0;i<NOF_PACKETS;++i)
       packet_sz[i]=rand(6)*10;
        for(i=0;i<NOF_PACKETS;++i)
                printf("packet[%d]:%d bytes\t",i,packet_sz[i]);
        printf("\nEnter the Output rate:");
        scanf("%d",&o_rate);
        printf("Enter the Bucket Size:");
        scanf("%d",&b_size);
        for(i=0; i<NOF_PACKETS; ++i)
        {
         if( (packet_sz[i] + p_sz_rm) > b_size)
		  if(packet_sz[i] > b_size)/*compare the packet siz with bucket size*/
			printf("\n\nIncomming packet size (%dbytes) is Greater than bucket capacity (%dbytes)-PACKET REJECTED",packet_sz[i],b_size);
		  else
			printf("\n\nBucket capacity exceeded-PACKETS REJECTED!!");
         else
         {
	 	  p_sz_rm += packet_sz[i];
	  	  printf("\n\nIncomming Packet size: %d",packet_sz[i]);
	  	  printf("\nBytes remaining to Transmit: %d",p_sz_rm);
	  	  p_time = rand(4)*10;
	     	  printf("\nTime left for transmission: %d units",p_time);
	  	  for(clk=10; clk<=p_time; clk+=10)
	  	  {
	    	   sleep(1);
	    	   if(p_sz_rm)
	    	   {
	     	    if(p_sz_rm <= o_rate)/*packet size remaining comparing with output rate*/
	       	      op = p_sz_rm,p_sz_rm = 0;
	     	    else
	       	      op = o_rate,p_sz_rm -= o_rate;
	       	      printf("\n  Packet of size %d Transmitted",op);
	       	      printf("----Bytes Remaining to Transmit: %d",p_sz_rm);
	    	   }
	    	   else
	    	   {
	       	    printf("\nTime left for transmission: %d units",p_time-clk);
		    	printf("\n  No packets to transmit!!");
	    	   }
		  }
         }
        }
    }

###Output:
*Commands for execution:-*

* Open a terminal.
* Change directory to the file location.
* Run gcc *filename.c*
* If there are no errors, run ./a.out

*Screenshots:-*
	
![ScreenShot of Output](leakybucket1.png) 
![ScreenShot of Output](leakybucket2.png)
![ScreenShot of Output](leakybucket3.png)



